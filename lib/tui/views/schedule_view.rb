# frozen_string_literal: true

require 'io/console'

module TUI
  module Views
    class ScheduleView < BaseView
      def display
        puts header("Schedule Post - #{persona.name}")

        result = select_next_post

        if result[:error]
          puts error(result[:error])
          wait_for_key
          return
        end

        show_preview(result)
        confirm_schedule(result)
      end

      private

      def select_next_post
        service = ContentStrategy::PreparePostContent.new(persona: persona)
        result = service.call

        unless result[:success]
          return { error: result[:error] || 'Unknown error' }
        end

        {
          pillar: result[:pillar],
          cluster: result[:cluster],
          photo: result[:photo],
          caption: result[:caption],
          hashtags: result[:hashtags],
          optimal_time: result[:optimal_time]
        }
      rescue StandardError => e
        { error: "Failed to select post: #{e.message}" }
      end

      def show_preview(result)
        puts section_header("POST PREVIEW")

        puts "\n#{pastel.bold('Pillar:')} #{result[:pillar]&.name || 'None'}"
        puts "#{pastel.bold('Cluster:')} #{result[:cluster]&.name || 'None'}"
        puts "#{pastel.bold('Photo:')} #{File.basename(result[:photo].path)}"
        
        if result[:optimal_time]
          puts "#{pastel.bold('Scheduled Time:')} #{result[:optimal_time].strftime('%A, %B %-d at %-I:%M %p')}"
        end

        # Show caption metadata if available
        if result[:caption_metadata]
          puts "#{pastel.dim("Generated by: #{result[:caption_metadata][:generated_by]} (#{result[:caption_metadata][:model] || 'unknown'})")}"
        end

        puts "\n#{pastel.bold('Caption:')}"
        puts pastel.dim("─" * 80)
        if result[:caption].blank?
          puts pastel.yellow("(No caption generated)")
        else
          puts result[:caption]
        end
        puts pastel.dim("─" * 80)

        if result[:hashtags]&.any?
          puts "\n#{pastel.bold('Hashtags:')}"
          puts result[:hashtags].join(' ')
        end
      end

      def confirm_schedule(result)
        puts "\n" + pastel.dim("─" * 80)
        puts pastel.dim("Actions: [s] schedule  [r] regenerate caption  [e] edit caption  [c] cancel")

        loop do
          print "\n#{pastel.cyan('What would you like to do?')} "
          $stdout.flush
          choice = $stdin.getch.downcase
          puts # newline after input

          case choice
          when 's'
            schedule_post(result)
            break
          when 'r'
            regenerate_and_preview(result)
            break
          when 'e'
            edit_and_schedule(result)
            break
          when 'c', 'q', "\e"
            puts warning('Cancelled')
            wait_for_key
            break
          else
            puts warning("Invalid choice. Please press s, r, e, or c")
          end
        end
      end

      def schedule_post(result)
        scheduled_time = result[:optimal_time] || Time.now + 1.hour
        
        post = Scheduling::Post.create!(
          persona: persona,
          photo: result[:photo],
          caption: result[:caption],
          hashtags: result[:hashtags],
          scheduled_at: scheduled_time,
          status: 'scheduled',
          cluster: result[:cluster]
        )

        puts "\n#{success("Post scheduled for #{scheduled_time.strftime('%m/%d at %-I:%M %p')}")}"
        wait_for_key
      rescue StandardError => e
        puts "\n#{error("Failed to schedule: #{e.message}")}"
        wait_for_key
      end

      def regenerate_and_preview(result)
        provider = ENV['GEMINI_API_KEY'].present? ? 'Gemini 2.5 Pro' : 'Ollama gemma3:27b'
        puts "\n#{pastel.yellow("Regenerating caption with #{provider}...")}"
        
        begin
          caption_result = CaptionGenerations::Generator.generate(
            photo: result[:photo],
            persona: persona,
            cluster: result[:cluster],
            options: { variations: 1 }
          )
          
          # Combine caption with hashtags
          new_caption = caption_result.text
          if result[:hashtags]&.any? && !new_caption.include?('#')
            new_caption = "#{new_caption}\n\n#{result[:hashtags].join(' ')}"
          end
          
          result[:caption] = new_caption
          result[:caption_metadata] = caption_result.metadata
          
          puts "#{success('Caption regenerated!')}\n"
          show_preview(result)
          confirm_schedule(result)
        rescue StandardError => e
          puts "\n#{error("Failed to regenerate caption: #{e.message}")}"
          wait_for_key
          confirm_schedule(result)
        end
      end

      def edit_and_schedule(result)
        editor = ENV['EDITOR'] || 'nano'
        tmpfile = Tempfile.new(['caption', '.txt'])

        begin
          tmpfile.write(result[:caption])
          tmpfile.close

          system("#{editor} #{tmpfile.path}")

          edited_caption = File.read(tmpfile.path).strip

          if edited_caption.empty?
            puts "\n#{error('Caption cannot be empty')}"
            wait_for_key
            return
          end

          result[:caption] = edited_caption
          schedule_post(result)
        ensure
          tmpfile.unlink
        end
      end
    end
  end
end
